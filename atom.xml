<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Calyp</title>
  <subtitle>Study</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="calyp.github.io/"/>
  <updated>2017-06-02T08:25:37.278Z</updated>
  <id>calyp.github.io/</id>
  
  <author>
    <name>Calyp</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo相关</title>
    <link href="calyp.github.io/2017/06/02/Hexo%E7%9B%B8%E5%85%B3/"/>
    <id>calyp.github.io/2017/06/02/Hexo相关/</id>
    <published>2017-06-02T08:05:45.000Z</published>
    <updated>2017-06-02T08:25:37.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Hexo无法正常显示公式"><a href="#Hexo无法正常显示公式" class="headerlink" title="Hexo无法正常显示公式"></a>Hexo无法正常显示公式</h2><p>善用主题(theme)，以我使用的next主题为例，打开/themes/next/_config.yml文件，更改mathjax开关为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># MathJax Support</div><div class="line">mathjax:</div><div class="line">  enable: true</div><div class="line">  per_page: true</div></pre></td></tr></table></figure>
<p>另外，还要在文章(.md文件)头设置开关，只用在有用公式显示的页面才加载Mathjax渲染，不影响其他的页面渲染速度，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: index.html</div><div class="line">date: 2016-12-28 21:01:30</div><div class="line">tags:</div><div class="line">mathjax: true</div><div class="line">--</div></pre></td></tr></table></figure>
<p>题外话，可以在/scaffolds/post.md文件中添加mathjax一行，这样每次layout如果是由默认的post 生成新的文章的开头都会有mathjax，可以自己选择true或是false(注意mathjax冒号后面不要掉了空格)，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">title: &#123;&#123; title &#125;&#125;</div><div class="line">date: &#123;&#123; date &#125;&#125;</div><div class="line">categories: </div><div class="line">tags:</div><div class="line">description: </div><div class="line">mathjax:</div></pre></td></tr></table></figure>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;h2 id=&quot;Hexo无法正常显示公式&quot;&gt;&lt;a href=&quot;#Hexo无法正常显示公式&quot; class=&quot;headerlink&quot; title=&quot;H
    
    </summary>
    
      <category term="Hexo" scheme="calyp.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="calyp.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>待办及进度</title>
    <link href="calyp.github.io/2017/06/02/%E5%BE%85%E5%8A%9E%E5%8F%8A%E8%BF%9B%E5%BA%A6/"/>
    <id>calyp.github.io/2017/06/02/待办及进度/</id>
    <published>2017-06-02T07:15:46.000Z</published>
    <updated>2017-06-02T07:15:46.160Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>杂知识点</title>
    <link href="calyp.github.io/2017/06/01/%E6%9D%82%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>calyp.github.io/2017/06/01/杂知识点/</id>
    <published>2017-06-01T01:42:05.000Z</published>
    <updated>2017-06-02T08:13:40.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分类与回归"><a href="#分类与回归" class="headerlink" title="分类与回归"></a>分类与回归</h1><p><em>分类与回归的模型本质一样，分类模型可将回归模型的输出离散化，回归模型也可将分类模型的输出连续化。</em></p>
<ol>
<li><p>Logistic Regression&amp;Linear Regression:</p>
<ul>
<li>Linear Regression:输出一个标量<strong>wx+b</strong>，这个值是连续值，用以回归问题</li>
<li>Logistic Regression:将上面的<strong>wx+b</strong>通过<strong>sigmoid</strong>函数映射到(0,1)上，划分阈值，大于阈值的分为一类，小于的分为另一类，用以处理二分类的问题</li>
<li>对于N分类问题，可以先计算N组w值不同的<strong>wx+b</strong> ，然后归一化，比如<strong>softmax</strong>函数变成N个类上的概率，用以多分类</li>
</ul>
</li>
<li><p>SVR &amp;SVM</p>
<ul>
<li>SVR:输出<strong>wx+b</strong>，即某个样本点到分类面的距离，是连续值，属于回归问题</li>
<li>SVM：将SVR的距离用sign(.)函数作用，距离为正的样本点属于一类，为负的属于另一类</li>
</ul>
</li>
<li><p>Naive Bayes用来分类和回归</p>
</li>
<li><p>前馈神经网络（CNN系列）用于分类和回归</p>
<ul>
<li>回归：最后一层有m个神经元，每个神经元输出一个标量，m个神经元的三个月抽根烟截图看做向量v，现全部连接到一个神经元上，这个神经元的输出<strong>wv+b</strong>，是一个连续值，处理回归问题，和Linear Regression的思想一样</li>
<li>分类：将m个神经元最后连接到N个神经元，有N组不同的<strong>wv+b</strong>，进行归一化（比如softmax)，就变成N个类上的概率，如果不用softmax，而是每个wx+b用一个sigmoid，就变成多标签问题</li>
</ul>
</li>
<li><p>循环神经网络（RNN系列）用于分类和回归</p>
<ul>
<li><p>回归和分类与CNN类似，输出层的值<strong>y=wx+b</strong>，可做分类和回归，区别在于，RNN的输出和时间有关，即输出的是{y(t),y(t+1),..}序列</p>
<p>​</p>
</li>
</ul>
<h1 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1><p><strong>迁移学习</strong>：有监督预训练(<em>supervised pre-training</em>)，把一个任务训练好的参数拿到另一个任务作为神经网络的初始参数值。</p>
<p><strong>IoU(交并比)</strong>:定位精度的评价公式<br>$$<br>IoU=\frac{A\cap B}{A\cup B}<br>$$</p>
</li>
</ol>
<p>​        <strong>NMS(非极大值抑制)</strong>:如果重叠度超过NMS，则丢弃</p>
<p>​    <strong>准确率&amp;精确率&amp;召回率</strong>:</p>
<p>​    <em>准确率是正确预测的样本占总的预测样本比例</em></p>
<p>​    <em>精确率是预测为正的样本中有多少是真的正类</em></p>
<p>​    <em>召回率是样本中有多少正例被正确的预测</em></p>
<p>​    <em>F值=准确率<em>\</em>召回率*2/(准确率+召回率)，是准确率和召回率的调和平均值</em></p>
<p>​    <em>TP</em>：正类被预测为正类</p>
<p>​    <em>FN</em>：正类被预测为负类</p>
<p>​    <em>FP</em>：负类被预测为正类</p>
<p>​    <em>TN</em>：负类被预测为负类<br>$$<br>准确率=\frac{TP+TN}{TP+TF+FN+FP}<br>$$</p>
<ul>
<li>$$<br>精确率=\frac{TP}{TP+FP}<br>$$</li>
</ul>
<p>$$<br>召回率=\frac{TP}{TP+FN}<br>$$</p>
<p>​    <strong>卷积计算后的图片尺寸</strong>：</p>
<p>$$<br>outputsize=\frac{imagesize+2<em>padding-kernelsize}{stride}<br>$$<br>​    <em>*RankBoost</em></em>:</p>
<p>​    RankBoost的思想比较简单，是二元Learning to rank的常规思路：通过构造目标分类    器，使得pair之间的对象存在相对大小关系。通俗点说，把对象组成一对对的pair，比如一组排序r1&gt;r2&gt;r3&gt;r4，那可以构成pair：(r1,r2)(r1,r3),(r1,r4),(r2,r3)(r3,r4),这样的pair是正值，也就是label是1；而余下的pair如(r2,r1)的值应该是-1或0。这样一个排序问题就被巧妙的转换为了分类问题。近来CV界很多又用这种learning to rank的思想做识别问题，先把识别转换为排序问题再转换为分类问题</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分类与回归&quot;&gt;&lt;a href=&quot;#分类与回归&quot; class=&quot;headerlink&quot; title=&quot;分类与回归&quot;&gt;&lt;/a&gt;分类与回归&lt;/h1&gt;&lt;p&gt;&lt;em&gt;分类与回归的模型本质一样，分类模型可将回归模型的输出离散化，回归模型也可将分类模型的输出连续化。&lt;/em&gt;&lt;
    
    </summary>
    
      <category term="深度学习" scheme="calyp.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="calyp.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="calyp.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
